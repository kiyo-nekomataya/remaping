/* punchoutWhite.jsx    Photoshop アニメーション作業スクリプト    [255,255,255]を透明に抜く    領域化された通常レイヤーのみ有効    バッチ処理用 複数レイヤを順次処理    レイヤ調整レイヤ等はスキップ    仕様上背景レイヤーが選択されている場合はエラーが発生する    通常の作業時は単領域を彩色したほうがはやいぞ    2021.03.17 kiyo@nekomataya.info*/if(app.documents.length){	var myTarget=app.activeDocument;    var White = new SolidColor();    White.rgb.red   = 255;    White.rgb.green = 255;    White.rgb.blue  = 255;//選択状態の取得    var selected = null;    try{        selected = app.activeDocument.selection.bounds;        try {            app.activeDocument.selection.invert();        }catch(er){            selected = false;        }    }catch(err){        selected = false;    }    app.activeDocument.selection.deselect();/* *	Photoshop 拡張スクリプト用 *	ライブラリに依存しない形で現在選択されているレイヤーの配列を返す *	レイヤセット、レイヤーを問わず選択中のアイテムを返す *	実行時にもとの選択状態を維持する *	返り値の配列はレイヤーが下から順になっているので注意 */function getSelectedLayers (){	var layersIndexes = [];//ID配列	var result = [];//レイヤー配列	var ref = new ActionReference();	ref.putEnumerated( charIDToTypeID("Dcmn"), charIDToTypeID("Ordn"), charIDToTypeID("Trgt") );	var desc = executeActionGet(ref);	if ( desc.hasKey( stringIDToTypeID( 'targetLayers' ) ) ){		desc = desc.getList( stringIDToTypeID( 'targetLayers' ));		var c = desc.count;		for(var i=0;i<c;i++){ 			try{				activeDocument.backgroundLayer;				layersIndexes.push(  desc.getReference( i ).getIndex() );			}catch(e){				layersIndexes.push(  desc.getReference( i ).getIndex()+1 );			};		};	}else{		var ref = new ActionReference();		ref.putProperty( charIDToTypeID("Prpr") , charIDToTypeID( "ItmI" ));		ref.putEnumerated( charIDToTypeID("Lyr "), charIDToTypeID("Ordn"), charIDToTypeID("Trgt") );		try{			activeDocument.backgroundLayer; 			layersIndexes.push( executeActionGet(ref).getInteger(charIDToTypeID( "ItmI" ))-1); 		}catch(e){ 			layersIndexes.push( executeActionGet(ref).getInteger(charIDToTypeID( "ItmI" ))); 		};		var vis = app.activeDocument.activeLayer.visible;		if (vis == true) app.activeDocument.activeLayer.visible = false;		var descE = new ActionDescriptor();		var listE = new ActionList();		var refE = new ActionReference();		refE.putEnumerated( charIDToTypeID('Lyr '), charIDToTypeID('Ordn'), charIDToTypeID('Trgt') );		listE.putReference( refE );		descE.putList( charIDToTypeID('null'), listE );		executeAction( charIDToTypeID('Shw '), descE, DialogModes.NO );		if(app.activeDocument.activeLayer.visible == false) layersIndexes.shift();		app.activeDocument.activeLayer.visible = vis;	};//取得したID配列からレイヤを追加選択してアクティブアイテムを控える//IDはレイヤの（表示プライオリティ）下層から順に並んでいるので選択するごとに最上位のレイヤーがアクティブになる	for( var i = 0; i < layersIndexes.length; i++ ){		var desc = new ActionDescriptor();		var ref = new ActionReference();		ref.putIndex(charIDToTypeID( "Lyr " ), layersIndexes[i])		desc.putReference( charIDToTypeID( "null" ), ref );		if ( i > 0 ) {			var idselectionModifier     = stringIDToTypeID( "selectionModifier" );			var idselectionModifierType = stringIDToTypeID( "selectionModifierType" );			var idaddToSelection        = stringIDToTypeID( "addToSelection" );			desc.putEnumerated( idselectionModifier, idselectionModifierType, idaddToSelection );		};//desc.putBoolean( charIDToTypeID( "MkVs" ), visible );		executeAction( charIDToTypeID( "slct" ), desc, DialogModes.NO );		result.push(app.activeDocument.activeLayer);	};	return result;}/** *	指定座標のアクティブレイヤの色をSolidColorで返す関数 *	指定座標にピクセルがない場合はnullを返す *	@params {Object Document}  doc *	@params {Array} pos *		[x,y] as px *	@returns {Object SolidColor | null} *	2021 03 17 kiyo@nekomataya.info */function getColorAt(doc, pos) {	function selectBounds(doc, b) {      doc.selection.select([[ b[0], b[1] ],                           [ b[2], b[1] ],                           [ b[2], b[3] ],                           [ b[0], b[3] ]]);    }    function findPV(h) {      for (var i = 0; i <= 255; i++ ) {        if (h[i]) { return i; }      }      return 0;    }	var x=pos[0];	var y=pos[1];	var orgLyr = doc.activeLayer;	selectBounds(doc, [x, y, x+1, y+1]);	doc.selection.fill(White,ColorBlendMode.DARKEN);	doc.selection.copy();//コピー	var topLyr = doc.artLayers.add();//最上位にレイヤーを作る	doc.paste();//ペースト・ここで選択解除される	selectBounds(doc, [x, y, x+1, y+1]);//再選択	var pColor = new SolidColor();	pColor.rgb.red   = findPV(doc.channels[0].histogram);	pColor.rgb.green = findPV(doc.channels[1].histogram);	pColor.rgb.blue  = findPV(doc.channels[2].histogram);	doc.selection.deselect(); //選択解除	topLyr.remove();//一時レイヤ削除	doc.activeLayer = orgLyr; //アクティブレイヤ復帰	return pColor;};function punchoutWhite(){//座標点[0,0]のピクセルをSolidColor|nullでバックアップ    var cBack = getColorAt(myTarget,[0,0]);//座標点[0,0]をターゲット色でペイント-解除    myTarget.selection.select([[0,0],[1,0],[1,1],[0,1]]);    myTarget.selection.fill(White,ColorBlendMode.NORMAL);    myTarget.selection.deselect();//=======================================================透明フィルvar idFl = charIDToTypeID( "Fl  " );    var desc25 = new ActionDescriptor();    var idFrom = charIDToTypeID( "From" );        var desc26 = new ActionDescriptor();        var idHrzn = charIDToTypeID( "Hrzn" );        var idRlt = charIDToTypeID( "#Rlt" );        desc26.putUnitDouble( idHrzn, idRlt, 0.000000 );        var idVrtc = charIDToTypeID( "Vrtc" );        var idRlt = charIDToTypeID( "#Rlt" );        desc26.putUnitDouble( idVrtc, idRlt, 0.000000 );    var idPnt = charIDToTypeID( "Pnt " );    desc25.putObject( idFrom, idPnt, desc26 );    var idTlrn = charIDToTypeID( "Tlrn" );    desc25.putInteger( idTlrn, 0 );    var idUsng = charIDToTypeID( "Usng" );    var idFlCn = charIDToTypeID( "FlCn" );    var idFrgC = charIDToTypeID( "FrgC" );    desc25.putEnumerated( idUsng, idFlCn, idFrgC );    var idMd = charIDToTypeID( "Md  " );    var idBlnM = charIDToTypeID( "BlnM" );    var idClar = charIDToTypeID( "Clar" );    desc25.putEnumerated( idMd, idBlnM, idClar );    var idCntg = charIDToTypeID( "Cntg" );    desc25.putBoolean( idCntg, false );executeAction( idFl, desc25, DialogModes.NO );//元ピクセルが [255,255,255] 以外なら復帰する    if( (cBack.rgb.red   != 255)||        (cBack.rgb.green != 255)||        (cBack.rgb.blue  != 255)    ){        myTarget.selection.select([[0,0],[1,0],[1,1],[0,1]]);        myTarget.selection.fill(cBack,ColorBlendMode.NORMAL);        myTarget.selection.deselect();    }}    //UNDO設定var myLayers = getSelectedLayers();var myUndo   = localize({en:"punchoutWhite",ja:"白部分削除"});var myAction = "if(myLayers.length > 1)myTarget.activeLayer=myLayers[myLayers.length-1];for(var ix=0;ix<myLayers.length;ix ++){var vs=myLayers[ix].visible;if(myLayers[ix].kind==LayerKind.NORMAL){if(!vs) myLayers[ix].visible=true;activeDocument.activeLayer=myLayers[ix];punchoutWhite();};if(!vs) myLayers[ix].visible=false;};";	if(app.activeDocument.suspendHistory){app.activeDocument.suspendHistory(myUndo,myAction)}else{eval(myAction)};}else{    alert("no Documents")}